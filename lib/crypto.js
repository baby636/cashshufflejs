// Generated by CoffeeScript 2.3.2
(function() {
  var Crypto, PrivateKey, PublicKey, aesDecryptWithIV, aesEncryptWithIV, crypto;

  ({PrivateKey, PublicKey} = require('bitcoincashjs-fork'));

  crypto = require("crypto");

  aesEncryptWithIV = function(key, iv, message) {
    var cipher, crypted;
    cipher = crypto.createCipheriv('aes-128-cbc', key, iv);
    cipher.setAutoPadding(true);
    crypted = cipher.update(message, 'hex', 'hex');
    crypted += cipher.final('hex');
    return Buffer.from(crypted, 'hex');
  };

  aesDecryptWithIV = function(key, iv, message) {
    var cipher, crypted;
    cipher = crypto.createDecipheriv('aes-128-cbc', key, iv);
    cipher.setAutoPadding(true);
    crypted = cipher.update(message, 'hex', 'hex');
    crypted += cipher.final('hex');
    return Buffer.from(crypted, 'hex');
  };

  Crypto = class Crypto {
    constructor() {}

    generateKeyPair() {
      return this.privateKey = new PrivateKey;
    }

    exportPrivareKey() {
      if (this.privateKey) {
        return this.privateKey.toString('hex');
      } else {
        return null;
      }
    }

    restoreFromPrivateKey(secretHex) {
      var error;
      try {
        return this.privateKey = new PrivateKey(secretHex);
      } catch (error1) {
        error = error1;
        return null;
      }
    }

    exportPublicKey() {
      return this.privateKey.publicKey.toString('hex');
    }

    encrypt(message, pubkey) {
      var ciphertext, ecdhKey, encrypted, ephemeral, iv, key, keyE, keyM, mac, prefix, publicKey, secretMultiplier;
      publicKey = PublicKey(pubkey);
      ephemeral = new PrivateKey;
      secretMultiplier = ephemeral.toBigNumber();
      ecdhKey = PublicKey(publicKey.point.mul(secretMultiplier)).toBuffer();
      key = crypto.createHash('sha512').update(ecdhKey).digest();
      [iv, keyE, keyM] = [key.slice(0, 16), key.slice(16, 32), key.slice(32)];
      ciphertext = aesEncryptWithIV(keyE, iv, Buffer.from(message, 'utf8'));
      prefix = Buffer.from('BIE1');
      encrypted = Buffer.concat([prefix, ephemeral.publicKey.toBuffer(), ciphertext]);
      mac = crypto.createHmac('sha256', keyM).update(encrypted).digest();
      return Buffer.concat([encrypted, mac]).toString('base64');
    }

    decrypt(encryptedMessage) {
      var ciphertext, ecdhKey, encrypted, ephemeralPubkey, error, iv, key, keyE, keyM, mac, magic, secretMultiplier;
      encrypted = Buffer.from(encryptedMessage, 'base64');
      if (encrypted.length < 85) {
        throw "invalid ciphertext: length";
      }
      [magic, ephemeralPubkey, ciphertext, mac] = [encrypted.slice(0, 4), encrypted.slice(4, 37), encrypted.slice(37, -32), encrypted.slice(-32)];
      if (magic.toString() !== "BIE1") {
        throw "invalid ciphertext: invalid magic bytes";
      }
      try {
        ephemeralPubkey = PublicKey(ephemeralPubkey);
      } catch (error1) {
        error = error1;
        throw "invalid ciphertext: invalid ephemeral pubkey";
      }
      ephemeralPubkey.point.validate();
      secretMultiplier = this.privateKey.toBigNumber();
      ecdhKey = PublicKey(ephemeralPubkey.point.mul(secretMultiplier)).toBuffer();
      key = crypto.createHash('sha512').update(ecdhKey).digest();
      [iv, keyE, keyM] = [key.slice(0, 16), key.slice(16, 32), key.slice(32)];
      if (mac.toString('hex') !== crypto.createHmac('sha256', keyM).update(encrypted.slice(0, -32)).digest('hex')) {
        throw "invalid password";
      }
      return aesDecryptWithIV(keyE, iv, ciphertext);
    }

    hash(text, algorithm = 'sha224') {
      var error;
      try {
        return crypto.createHash(algorithm).update(Buffer.from(text), "utf8").digest();
      } catch (error1) {
        error = error1;
        return null;
      }
    }

  };

  module.exports = Crypto;

}).call(this);
