// Generated by CoffeeScript 2.3.2
(function() {
  var Comms, WebSocket, http, https, magic, queue, url;

  url = require("url");

  http = require("http");

  https = require("https");

  WebSocket = require("ws");

  queue = require("queue");

  // Получение от сервера инфы
  // Если данные, то брать их и класть в очередь
  // Если отправка, запаковывать и отправлять
  magic = Buffer.from("42bcc32669467873", "hex");

  Comms = class Comms {
    constructor(path1) {
      this.path = path1;
      this.incomeBuffer = Buffer.alloc(0);
      this.result = queue();
      this.result.on("success", (result, job) => {});
      this.inchan = [];
    }

    checkProtocol() {
      var protocol;
      protocol = url.parse(this.path).protocol;
      this.ssl = null;
      if (protocol === "http:") {
        this.ssl = false;
      }
      if (protocol === "https:") {
        this.ssl = true;
      }
      if (this.ssl === null) {
        throw new Error("bad cashshuffle server path");
      }
    }

    getStats() {
      var path, ssl;
      ssl = this.ssl;
      path = this.path;
      return new Promise(function(resolve, reject) {
        var client;
        client = ssl ? https : http;
        return client.get(url.resolve(path, "/stats"), function(res) {
          var rawData;
          if (res.statusCode !== 200) {
            resolve(new Error("no stats endpoint on server"));
          }
          rawData = "";
          res.on("data", function(chunk) {
            return rawData += chunk.toString();
          });
          return res.on("end", function() {
            return resolve(JSON.parse(rawData));
          });
        }).on("error", function(error) {
          return reject(error);
        });
      });
    }

    setupWebsocket() {
      return this.getStats().then((res) => { // using this type of arrow => instead of -> allows you to modify the class context
        return this.wsPort = res.shuffleWebSocketPort;
      }).catch(function(error) {
        throw error;
      });
    }

    parseMessage() {
      var messageLength, results;
      results = [];
      while (this.incomeBuffer.length > 12) {
        if (this.incomeBuffer.slice(0, 8).toString('hex') !== magic.toString('hex')) {
          throw new Error("bad magic word");
        }
        messageLength = this.incomeBuffer.slice(8, 12).readUInt32BE();
        if (this.incomeBuffer.slice(12).length >= messageLength) {
          this.incomeBuffer = this.incomeBuffer.slice(12);
          this.result.push((cb) => {
            this.inchan.push(this.incomeBuffer.slice(0, messageLength));
            return cb();
          });
          results.push(this.incomeBuffer = this.incomeBuffer.slice(messageLength));
        } else {
          break;
        }
      }
      return results;
    }

    send(message) {
      var error, lengthSuffix;
      lengthSuffix = Buffer.alloc(4);
      lengthSuffix.writeUIntBE(message.length, 0, 4);
      try {
        this.wsClient.send(Buffer.concat([magic, lengthSuffix, message]));
      } catch (error1) {
        error = error1;
        new Error("unable to send to socket");
      }
      return console.log(lengthSuffix);
    }

    recv() {
      return new Promise((resolve, reject) => {
        this.result.start((err) => {
          if (err) {
            return reject(err);
          }
        });
        return resolve(this.inchan.pop());
      });
    }

    makeConnection(greetingMessage) {
      return new Promise((resolve, reject) => {
        var hostname, origin, protocol, wsPath, wsProtocol;
        ({hostname, protocol} = url.parse(this.path));
        wsProtocol = this.ssl ? "wss:" : "ws:";
        wsPath = wsProtocol + "//" + hostname + ":" + this.wsPort + "/";
        origin = protocol + "//" + hostname + ":" + this.wsPort + "/";
        this.wsClient = new WebSocket(wsPath, {
          origin: origin
        });
        this.wsClient.on('open', () => {
          this.send(greetingMessage);
          return resolve(true);
        });
        this.wsClient.on('message', (msg) => {
          this.incomeBuffer = Buffer.concat([this.incomeBuffer, msg]);
          return this.parseMessage();
        });
        return this.wsClient.on('error', (error) => {
          return reject(error);
        });
      });
    }

  };

  module.exports = Comms;

}).call(this);
