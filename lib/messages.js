// Generated by CoffeeScript 2.3.2
(function() {
  var Address, BchMessage, Blame, Coins, DecryptionKey, EncryptionKey, Hash, Inputs, Invalid, Message, Messages, Packet, Packets, Phase, Reason, Registration, Signature, Signatures, Signed, Transaction, VerificationKey, message_root, protobuf, valOrNull,
    indexOf = [].indexOf;

  protobuf = require('protobufjs');

  BchMessage = require('bitcoincashjs-fork').Message;

  message_root = protobuf.loadSync("./protobuf/message.proto");

  Signed = message_root.lookupType("Signed");

  Packet = message_root.lookupType("Packet");

  Phase = message_root.lookupEnum("Phase");

  Coins = message_root.lookupType("Coins");

  Signatures = message_root.lookupType("Signatures");

  Message = message_root.lookupType("Message");

  Address = message_root.lookupType("Address");

  Registration = message_root.lookupType("Registration");

  VerificationKey = message_root.lookupType("VerificationKey");

  EncryptionKey = message_root.lookupType("EncryptionKey");

  DecryptionKey = message_root.lookupType("DecryptionKey");

  Hash = message_root.lookupType("Hash");

  Signature = message_root.lookupType("Signature");

  Transaction = message_root.lookupType("Transaction");

  Blame = message_root.lookupType("Blame");

  Reason = message_root.lookupEnum("Reason");

  Invalid = message_root.lookupType("Invalid");

  Inputs = message_root.lookupType("Inputs");

  Packets = message_root.lookupType("Packets");

  valOrNull = function() {
    return function(method) {
      return function() {
        var error;
        try {
          return method.apply(this, arguments);
        } catch (error1) {
          error = error1;
          return null;
        }
      };
    };
  };

  Messages = (function() {
    class Messages {
      constructor() {
        this.packets = Packets.create({
          packet: []
        });
      }

      makeGreeting(key, amount) {
        var message;
        message = Signed.create({
          packet: Packet.create({
            fromKey: VerificationKey.create({
              key: key
            }),
            registration: Registration.create({
              amount: amount
            })
          })
        });
        return this.packets.packet.push(message);
      }

      formAllPackets(eck, session, number, vkFrom, vkTo, phase) {
        var k, len, msg, packet, ref, results, sig, sig_bytes;
        ref = this.packets.packet;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          packet = ref[k];
          packet.packet.phase = Phase.values[phase.toUpperCase()];
          packet.packet.session = session;
          packet.packet.number = number;
          packet.packet.fromKey = VerificationKey.create({
            key: vkFrom
          });
          if (vkTo) {
            packet.packet.toKey = VerificationKey.create({
              key: vkTo
            });
          }
          msg = Packet.encode(packet.packet).finish().toString('base64');
          sig = BchMessage(msg).sign(eck);
          sig_bytes = Buffer.from(sig, "base64");
          results.push(packet.signature = Signature.create({
            signature: sig_bytes
          }));
        }
        return results;
      }

      generalBlame(reason, accused) {
        var packet, ref;
        this.clearPackets();
        packet = Signed.create({
          packet: Packet.create({
            message: Message.create({
              blame: Blame.create({
                accused: VerificationKey.create({
                  key: accused
                })
              })
            }),
            phase: Phase.values["BLAME"]
          })
        });
        if (ref = reason.toString(), indexOf.call(Object.keys(Reason.valuesById), ref) >= 0) {
          packet.packet.message.blame.reason = Reason.valuesById[reason.toString()];
        }
        return this.packets.packet.push(packet);
      }

      blameTheLiar(accused) {
        return this.generalBlame(Reason.values["LIAR"], accused);
      }

      blameInsufficientFunds(accused) {
        return this.generalBlame(Reason.values["INSUFFICIENTFUNDS"], accused);
      }

      blameEquivocationFailure(accused, invalidPackets = null) {
        this.generalBlame(Reason.values["EQUIVOCATIONFAILURE"], accused);
        if (invalidPackets) {
          return this.lastPacket().packet.message.blame.invalid = Invalid.create({
            invalid: invalidPackets
          });
        }
      }

      blameMissingOutputs(accused) {
        return this.generalBlame(Reason.values["MISSINGOUTPUT"], accused);
      }

      blameShuffleFailure(accused, hash) {
        this.generalBlame(Reason.values["SHUFFLEFAILURE"], accused);
        return this.lastPacket().packet.message.hash = Hash.create({
          hash: hash
        });
      }

      blameShuffleAndEquivocationFailure(accused, encryptionKey, decryptionKey, invalidPackets) {
        this.generalBlame(Reason.values["SHUFFLEANDEQUIVOCATIONFAILURE"], accused);
        this.lastPacket().packet.message.blame.invalid = Invalid.create({
          invalid: invalidPackets
        });
        return this.lastPacket().packet.message.blame.key = DecryptionKey.create({
          key: decryptionKey,
          public: encryptionKey
        });
      }

      blameInvalidSignature(accused) {
        return this.generalBlame(Reason.values["INVALIDSIGNATURE"], accused);
      }

      blameWrongTransactionSignature(accused) {
        return this.generalBlame(Reason.values["INVALIDSIGNATURE"], accused);
      }

      addEncryptionKey(ek, change) {
        var packet;
        packet = Signed.create({
          packet: Packet.create({
            message: Message.create({
              key: EncryptionKey.create({
                key: ek
              })
            })
          })
        });
        if (change) {
          packet.packet.message.address = Address.create({
            address: change
          });
        }
        return this.packets.packet.push(packet);
      }

      addInputs(inputsObject) {
        var key, packet, val;
        packet = Signed.create({
          packet: Packet.create({
            message: Message.create({
              inputs: {}
            })
          })
        });
        for (key in inputsObject) {
          val = inputsObject[key];
          packet.packet.message.inputs[key] = Coins.create({
            coins: val
          });
        }
        return this.packets.packet.push(packet);
      }

      addStr(str) {
        var packet;
        packet = Signed.create({
          packet: Packet.create({
            message: Message.create({
              str: str
            })
          })
        });
        return this.packets.packet.push(packet);
      }

      addHash(hash) {
        var packet;
        packet = Signed.create({
          packet: Packet.create({
            message: Message.create({
              hash: Hash.create({
                hash: hash
              })
            })
          })
        });
        return this.packets.packet.push(packet);
      }

      addSignatures(signatures) {
        var key, packet, val;
        packet = Signed.create({
          packet: Packet.create({
            message: Message.create({
              signatures: []
            })
          })
        });
        for (key in signatures) {
          val = signatures[key];
          packet.packet.message.signatures.push(Signature.create({
            utxo: key,
            signature: Signature.create({
              signature: val
            })
          }));
        }
        return this.packets.packet.push(packet);
      }

      getNewAddresses() {
        var k, len, packet, ref, results;
        ref = this.packets.packet;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          packet = ref[k];
          results.push(packet.packet.message.str);
        }
        return results;
      }

      getHashes() {
        var hashes, k, len, packet, ref;
        hashes = {};
        ref = this.packets.packet;
        for (k = 0, len = ref.length; k < len; k++) {
          packet = ref[k];
          hashes[packet.packet.fromKey.key] = packet.packet.message.hash.hash.toString('utf8');
        }
        return hashes;
      }

      getSignaturesAndPackets() {
        var k, len, packet, ref, results;
        ref = this.packets.packet;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          packet = ref[k];
          results.push([packet.signature.signature, Packet.encode(packet.packet).finish(), packet.packet.fromKey.key]);
        }
        return results;
      }

      getPlayers() {
        var k, len, packet, players, ref;
        players = {};
        ref = this.packets.packet;
        for (k = 0, len = ref.length; k < len; k++) {
          packet = ref[k];
          players[packet.packet.number] = packet.packet.fromKey.key;
        }
        return players;
      }

      getBlame() {
        var k, len, packet, ref, results;
        ref = this.packets.packet;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          packet = ref[k];
          results.push(packet.packet.message);
        }
        return results;
      }

      getStrs() {
        var k, len, packet, ref, results;
        ref = this.packets.packet;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          packet = ref[k];
          results.push(packet.packet.message.str);
        }
        return results;
      }

      //========== misc ==================
      shufflePackets() {
        var i, j, results, t;
        // i got it from cookbook https://coffeescript-cookbook.github.io/chapters/arrays/shuffling-array-elements
        i = this.packets.packet.length;
        results = [];
        while (--i > 0) {
          j = ~~(Math.random() * (i + 1));
          t = this.packets.packet[j];
          this.packets.packet[j] = this.packets.packet[i];
          results.push(this.packets.packet[i] = t);
        }
        return results;
      }

      lastPacket() {
        if (this.packets.packet.length) {
          return this.packets.packet[this.packets.packet.length - 1];
        } else {
          throw new Error('no last packet');
        }
      }

      clearPackets() {
        return this.packets = Packets.create({
          packet: []
        });
      }

      serialize() {
        return Packets.encode(this.packets).finish();
      }

      deserialize(buffer) {
        return this.packets = Packets.decode(buffer);
      }

    };

    Messages.prototype.getSession = valOrNull()(function() {
      return this.lastPacket().session;
    });

    Messages.prototype.getNumber = valOrNull()(function() {
      return this.lastPacket().packet.number;
    });

    Messages.prototype.getEncryptionKey = valOrNull()(function() {
      return this.lastPacket().packet.message.key.key;
    });

    Messages.prototype.getAddress = valOrNull()(function() {
      return this.lastPacket().packet.message.address.address;
    });

    Messages.prototype.getFromKey = valOrNull()(function() {
      return this.lastPacket().packet.message.fromKey.key;
    });

    Messages.prototype.getToKey = valOrNull()(function() {
      return this.lastPacket().packet.message.toKey.key;
    });

    Messages.prototype.getPhase = valOrNull()(function() {
      return this.lastPacket().packet.phase;
    });

    Messages.prototype.getHash = valOrNull()(function() {
      return this.lastPacket().packet.message.hash.hash;
    });

    Messages.prototype.getStr = valOrNull()(function() {
      return this.lastPacket().packet.message.str;
    });

    Messages.prototype.getInputs = valOrNull()(function() {
      var pubkey, ref, result, val;
      result = {};
      ref = this.lastPacket().packet.message.inputs;
      for (pubkey in ref) {
        val = ref[pubkey];
        result[pubkey] = val.coins;
      }
      return result;
    });

    Messages.prototype.getSignatures = valOrNull()(function() {
      var k, len, ref, result, signature;
      result = {};
      ref = this.lastPacket().packet.message.signatures;
      for (k = 0, len = ref.length; k < len; k++) {
        signature = ref[k];
        result[signature.utxo] = signature.signature.signature; // Amen!
      }
      // console.log @lastPacket().packet.message.signatures
      return result;
    });

    Messages.prototype.getBlameReason = valOrNull()(function() {
      return this.lastPacket().packet.message.blame.reason;
    });

    Messages.prototype.getAccusedKey = valOrNull()(function() {
      return this.lastPacket().packet.message.blame.accused.key;
    });

    Messages.prototype.getInvalidPackets = valOrNull()(function() {
      return this.lastPacket().packet.message.blame.invalid.invalid;
    });

    Messages.prototype.getPublicKey = valOrNull()(function() {
      return this.lastPacket().packet.message.blame.key.public;
    });

    Messages.prototype.getDecryptionKey = valOrNull()(function() {
      return this.lastPacket().packet.message.blame.key.key;
    });

    return Messages;

  }).call(this);

  //============== Export ==============
  module.exports = Messages;

}).call(this);
